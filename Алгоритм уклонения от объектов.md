#### Алгоритм уклонения от объектов (при движении персонажа, в эмуляторе пространства и объектов)

**v1.4** - *by Gogik Ortey / Орлов Георгий*

---

##### Предисловие:

Здесь вы найдёте описание алгоритма, по которому работает персонаж. Всё окружение генерируется динамически, и состоит из кубов, цилиндров, капсул и сфер, произвольного размера, цвета (в градациях серого), а также повёрнутых на случайное количество градусов.

Этот макет собран и работает на основе конструктора Unity, а карта глубины генерируется при помощи открытой библиотеки OpenCV.

Код двух основных скриптов вы сможете найти рядом, с этим текстовым файлом.

---

##### Описание окна просмотра:

На главном (и единственном) экране, при запуске данной программы, вы увидите несколько окон. Каждое из них будет подписано.

1. То, что самое большое - это вид на уровне глаз персонажа. Два окна поменьше слева - это левая и правая камеры. Они отдалены друг от друга, на 0,2 юнита (при том, что персонаж имеет размер 1х1х2 юнита)

2. Далее, правее расположена карта глубины. Именно она генерируется скриптом, из тех двух изображений, с левой и правой камеры. Эта карта преимущественно чёрная, и чем светлее выглядит объект, тем он ближе к персонажу.

3. Дальше идёт окно сжатой карты глубины. Ниже будет описан алгоритм, по которому она сжимается, превращаясь в набор из 53 вертикальных линий.
   Также, поверх неё виден красный маркер (состоящий из 7 центральных линий). Это маркер центрального препятствия. Если какая-либо линия попадает в эту область, значит персонаж непременно столкнётся с препятствием, если продолжит движение в данном направлении.
4. Далее, справа стоит окно вида от 3го лица. Эта камера смотрит на персонажа сзади сверху, и позволяет пользователю (вам) более точно оценить тот факт, что персонаж не касается никаких препятствий
5. И последний экран - справа снизу - экран команд. На нём отображается скорость, и указания, которые получает персонаж, от управляющего скрипта распознавания препятствий. Их всего 5 штук:
   1. Серый блок сверху указывает на то, что перед персонажем обнаружено препятствие, и ему следует уменьшить скорость, и выбрать сторону для поворота в неё, и уклонения от препятствия
   2. Красных знак стоп снизу - указывает на то, что препятствие перед персонажем угрожающе близко, и ему стоит полностью остановиться, и разворачиваться в выбранную сторону до тех пор, пока перед ним не будет препятствий
   3. Стрелка справа - разворот направо
   4. Стрелка влево - разворот налево
   5. Препятствий нет, можно двигаться в обычном режиме

Также, для удобства, на экран выводится локальное время (с точностью до милисекунд), и частота кадров

---

##### Описание алгоритма:

В начале работы программы, мы запускаем скрипт OpenCV, который генерирует карту глубин, в потоковом формате. При таком варианте работы, задержки минимальные.

В конце работы программы, при её закрытии, мы останавливаем этот скрипт.

Вот что мы делаем каждый кадр. Количество fps - это число, сколько раз за секунду мы выполнили данный алгоритм:

1. Два изображения с левой и правой камер на персонаже, сохраняются в папку под названием _ExportImage, в директории программы

2. Скрипт OpenCV, который работает в потоковом режиме совершает следующее:

   1. Сначала, он копирует эти 2 изображения в рабочую папку
   2. Далее он из этих 2х изображений создаёт карту глубины, с заданными параметрами (numDisparities: 16 * 1, blockSize: 31)
   3. И сохраняет её в папку _ImportDephMap\NewDephMap.png
   4. А также он ждёт 10 милисекунд. Т.е. он срабатывает примерно 100 раз в секунду

3. Далее, Unity загружает эту карту глубины. Задержка тут не очень большая (около 0.25 или 0.2 секунд)

4. Затем, эта карта глубины сжимается в вертикальные линии 

   * Алгоритм сжатия расписан ниже

5. И эти линии интерпретируются 

   * [1] Если в центральной зоне есть препятствие - делается пометка
   * [2] Если препятствие в центральной зоне угрожающе близко - делается другая пометка

6. Далее, используя эти 2 пометки, генерируются и передаются команды для персонажа

   * Если [1], то:
     * Скорость персонажа уменьшается (постепенно, с 2 до 0.5 единиц)
     * Выбирается сторона поворота. Это делается так: суммируется коэффициент близости препятствия справа и слева от центральной зоны (на сжатой карте глубин). И дальше, если справа меньше препятствий, поворачиваем направо. Если нет - налево.
     * Сторона поворота не изменяется до тех пор, пока в центральной зоне есть препятствие.
   * Если [2], то:
     * Персонаж останавливается
   * Разумеется, эти 2 условия могут работать одновременно.

   

   **Всего могут передаваться 4 команды:**

   * Стена впереди
   * Полная остановка
   * Поворот направо
   * Поворот налево
   * Препятствий не

---

##### Алгоритм сжатия карту глубины в изображение с вертикальными линиями:

1. Мы очищаем массив из 53 значений типа float. У нашей входной текстуры карты глубины ширина 532 пикселя. Мы складываем значения из 10 рядов, в одну ячейку в массиве.
2. Мы идём в двойном цикле for по рядам и строкам изображения, и смотрим - если значения пикселя больше, чем записано в массиве - мы перезаписываем значение.
3. Однако, сначала мы игнорируем 20 пикселей, значения который выше средних (выше 0.45 из 1.0 возможных). Это делается потому, что выходная карта глубины - шумная. А, убрав всего 20 пикселей, мы не пропустим препятствие, которое будет прямо перед нами, зато уберём лишний шум.

---

##### Небольшие хитрости, которые помогают в стабильности программы и алгоритма, и другая важная информация:

* При сжатии карты глубины в изображение с вертикальными линиями,  работа с этими линиям происходит как со значениями float в массиве. Картинка с линиями нужна только для удобства пользователя.
* Когда мы распознаём, близко ли препятствие перед персонажем, если мы распознали, что оно угрожающе близко, мы игнорируем эту информацию 2 раза. И, если на 3й раз оно всё также близко, значит так оно и есть.
  Просто иногда алгоритм генерации карты глубины даёт небольшой сбой, но всего на 1 кадр.
* Порог обнаружения любого препятствия - 0.45 из 1.0 возможных. Это отсекает дальние препятствия, которые нам интерпретировать не нужно. Порог обнаружения угрожающе близкого препятствия - 0.9
* Сторона, в которую персонаж будет поворачиваться, задаётся  при обнаружении препятствия, и не изменяется, пока препятствие не исчезнет из зоны видимости. Это сделано для того, что бы избежать возможных ловушек глубины (если выбирать направление поворота динамически, персонаж может начать дёргаться вокруг одной точки, т.к. попадёт в ловушку)
* Ошибки, в выгрузке или загрузке изображений с камер, и карты глубины, из файловой системы компьютера, происходят достаточно часто (около одного раза в 10-20 секунд). Мы просто их игнорируем, они всё равно ни на что не влияют
* Алгоритм генерации карты глубины, сначала копирует 2 входных изображения в папку _ExportImage\OutputNormalMap\ для того, что бы уменьшить количество ошибок, возникающих при создании и изменении изображений, в папках, на компьютере пользователя (файл может быть занят другим процессом, тогда его не получится удалить или заменить, тогда это будет ошибка)





























